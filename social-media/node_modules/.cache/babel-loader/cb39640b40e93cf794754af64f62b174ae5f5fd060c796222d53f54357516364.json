{"ast":null,"code":"import { composeEventHandlers as e } from \"@radix-ui/primitive\";\nimport { clamp as r } from \"@radix-ui/number\";\nimport { useLayoutEffect as t } from \"@radix-ui/react-use-layout-effect\";\nimport { useDirection as o } from \"@radix-ui/react-use-direction\";\nimport { useCallbackRef as n } from \"@radix-ui/react-use-callback-ref\";\nimport { useComposedRefs as l } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope as i } from \"@radix-ui/react-context\";\nimport { Presence as a } from \"@radix-ui/react-presence\";\nimport { Primitive as c } from \"@radix-ui/react-primitive\";\nimport * as s from \"react\";\nimport u from \"@babel/runtime/helpers/esm/extends\";\nconst [d, p] = i(\"ScrollArea\");\nexport { p as createScrollAreaScope };\nconst [f, h] = d(\"ScrollArea\");\nexport const ScrollArea = /*#__PURE__*/s.forwardRef((e, r) => {\n  const {\n      __scopeScrollArea: t,\n      type: n = \"hover\",\n      scrollHideDelay: i = 600,\n      ...a\n    } = e,\n    [d, p] = s.useState(null),\n    [h, m] = s.useState(null),\n    [w, b] = s.useState(null),\n    [v, S] = s.useState(null),\n    [g, E] = s.useState(null),\n    [C, T] = s.useState(0),\n    [y, A] = s.useState(0),\n    [x, R] = s.useState(!1),\n    [P, L] = s.useState(!1),\n    _ = l(r, e => p(e)),\n    D = o(d, a.dir); /*#__PURE__*/\n  return s.createElement(f, {\n    scope: t,\n    type: n,\n    dir: D,\n    scrollHideDelay: i,\n    scrollArea: d,\n    viewport: h,\n    onViewportChange: m,\n    content: w,\n    onContentChange: b,\n    scrollbarX: v,\n    onScrollbarXChange: S,\n    scrollbarXEnabled: x,\n    onScrollbarXEnabledChange: R,\n    scrollbarY: g,\n    onScrollbarYChange: E,\n    scrollbarYEnabled: P,\n    onScrollbarYEnabledChange: L,\n    onCornerWidthChange: T,\n    onCornerHeightChange: A\n  }, /*#__PURE__*/s.createElement(c.div, u({}, a, {\n    ref: _,\n    style: {\n      position: \"relative\",\n      \"--radix-scroll-area-corner-width\": C + \"px\",\n      \"--radix-scroll-area-corner-height\": y + \"px\",\n      ...e.style\n    }\n  })));\n}); /*#__PURE__*/\nexport const ScrollAreaViewport = /*#__PURE__*/s.forwardRef((e, r) => {\n  const {\n      __scopeScrollArea: t,\n      children: o,\n      ...n\n    } = e,\n    i = h(\"ScrollAreaViewport\", t),\n    a = s.useRef(null),\n    d = l(r, a, i.onViewportChange); /*#__PURE__*/\n  return s.createElement(s.Fragment, null, /*#__PURE__*/s.createElement(\"style\", {\n    dangerouslySetInnerHTML: {\n      __html: \"[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}\"\n    }\n  }), /*#__PURE__*/s.createElement(c.div, u({\n    \"data-radix-scroll-area-viewport\": \"\"\n  }, n, {\n    ref: d,\n    style: {\n      overflowX: i.scrollbarXEnabled ? \"scroll\" : \"hidden\",\n      overflowY: i.scrollbarYEnabled ? \"scroll\" : \"hidden\",\n      ...e.style\n    }\n  }), /*#__PURE__*/s.createElement(\"div\", {\n    ref: i.onContentChange,\n    style: {\n      minWidth: \"100%\",\n      display: \"table\"\n    }\n  }, o)));\n}); /*#__PURE__*/\nexport const ScrollAreaScrollbar = /*#__PURE__*/s.forwardRef((e, r) => {\n  const {\n      forceMount: t,\n      ...o\n    } = e,\n    n = h(\"ScrollAreaScrollbar\", e.__scopeScrollArea),\n    {\n      onScrollbarXEnabledChange: l,\n      onScrollbarYEnabledChange: i\n    } = n,\n    a = \"horizontal\" === e.orientation;\n  return s.useEffect(() => (a ? l(!0) : i(!0), () => {\n    a ? l(!1) : i(!1);\n  }), [a, l, i]), \"hover\" === n.type ? /*#__PURE__*/s.createElement(m, u({}, o, {\n    ref: r,\n    forceMount: t\n  })) : \"scroll\" === n.type ? /*#__PURE__*/s.createElement(w, u({}, o, {\n    ref: r,\n    forceMount: t\n  })) : \"auto\" === n.type ? /*#__PURE__*/s.createElement(b, u({}, o, {\n    ref: r,\n    forceMount: t\n  })) : \"always\" === n.type ? /*#__PURE__*/s.createElement(v, u({}, o, {\n    ref: r\n  })) : null;\n}); /*#__PURE__*/\nconst m = /*#__PURE__*/s.forwardRef((e, r) => {\n    const {\n        forceMount: t,\n        ...o\n      } = e,\n      n = h(\"ScrollAreaScrollbar\", e.__scopeScrollArea),\n      [l, i] = s.useState(!1);\n    return s.useEffect(() => {\n      const e = n.scrollArea;\n      let r = 0;\n      if (e) {\n        const t = () => {\n            window.clearTimeout(r), i(!0);\n          },\n          o = () => {\n            r = window.setTimeout(() => i(!1), n.scrollHideDelay);\n          };\n        return e.addEventListener(\"pointerenter\", t), e.addEventListener(\"pointerleave\", o), () => {\n          e.removeEventListener(\"pointerenter\", t), e.removeEventListener(\"pointerleave\", o);\n        };\n      }\n    }, [n.scrollArea, n.scrollHideDelay]), /*#__PURE__*/s.createElement(a, {\n      present: t || l\n    }, /*#__PURE__*/s.createElement(b, u({\n      \"data-state\": l ? \"visible\" : \"hidden\"\n    }, o, {\n      ref: r\n    })));\n  }),\n  w = /*#__PURE__*/s.forwardRef((r, t) => {\n    const {\n        forceMount: o,\n        ...n\n      } = r,\n      l = h(\"ScrollAreaScrollbar\", r.__scopeScrollArea),\n      i = \"horizontal\" === r.orientation,\n      c = z(() => p(\"SCROLL_END\"), 100),\n      [d, p] = (f = \"hidden\", m = {\n        hidden: {\n          SCROLL: \"scrolling\"\n        },\n        scrolling: {\n          SCROLL_END: \"idle\",\n          POINTER_ENTER: \"interacting\"\n        },\n        interacting: {\n          SCROLL: \"interacting\",\n          POINTER_LEAVE: \"idle\"\n        },\n        idle: {\n          HIDE: \"hidden\",\n          SCROLL: \"scrolling\",\n          POINTER_ENTER: \"interacting\"\n        }\n      }, s.useReducer((e, r) => {\n        const t = m[e][r];\n        return null != t ? t : e;\n      }, f));\n    var f, m;\n    return s.useEffect(() => {\n      if (\"idle\" === d) {\n        const e = window.setTimeout(() => p(\"HIDE\"), l.scrollHideDelay);\n        return () => window.clearTimeout(e);\n      }\n    }, [d, l.scrollHideDelay, p]), s.useEffect(() => {\n      const e = l.viewport,\n        r = i ? \"scrollLeft\" : \"scrollTop\";\n      if (e) {\n        let t = e[r];\n        const o = () => {\n          const o = e[r];\n          t !== o && (p(\"SCROLL\"), c()), t = o;\n        };\n        return e.addEventListener(\"scroll\", o), () => e.removeEventListener(\"scroll\", o);\n      }\n    }, [l.viewport, i, p, c]), /*#__PURE__*/s.createElement(a, {\n      present: o || \"hidden\" !== d\n    }, /*#__PURE__*/s.createElement(v, u({\n      \"data-state\": \"hidden\" === d ? \"hidden\" : \"visible\"\n    }, n, {\n      ref: t,\n      onPointerEnter: e(r.onPointerEnter, () => p(\"POINTER_ENTER\")),\n      onPointerLeave: e(r.onPointerLeave, () => p(\"POINTER_LEAVE\"))\n    })));\n  }),\n  b = /*#__PURE__*/s.forwardRef((e, r) => {\n    const t = h(\"ScrollAreaScrollbar\", e.__scopeScrollArea),\n      {\n        forceMount: o,\n        ...n\n      } = e,\n      [l, i] = s.useState(!1),\n      c = \"horizontal\" === e.orientation,\n      d = z(() => {\n        if (t.viewport) {\n          const e = t.viewport.offsetWidth < t.viewport.scrollWidth,\n            r = t.viewport.offsetHeight < t.viewport.scrollHeight;\n          i(c ? e : r);\n        }\n      }, 10);\n    return H(t.viewport, d), H(t.content, d), /*#__PURE__*/s.createElement(a, {\n      present: o || l\n    }, /*#__PURE__*/s.createElement(v, u({\n      \"data-state\": l ? \"visible\" : \"hidden\"\n    }, n, {\n      ref: r\n    })));\n  }),\n  v = /*#__PURE__*/s.forwardRef((e, r) => {\n    const {\n        orientation: t = \"vertical\",\n        ...o\n      } = e,\n      n = h(\"ScrollAreaScrollbar\", e.__scopeScrollArea),\n      l = s.useRef(null),\n      i = s.useRef(0),\n      [a, c] = s.useState({\n        content: 0,\n        viewport: 0,\n        scrollbar: {\n          size: 0,\n          paddingStart: 0,\n          paddingEnd: 0\n        }\n      }),\n      d = x(a.viewport, a.content),\n      p = {\n        ...o,\n        sizes: a,\n        onSizesChange: c,\n        hasThumb: Boolean(d > 0 && d < 1),\n        onThumbChange: e => l.current = e,\n        onThumbPointerUp: () => i.current = 0,\n        onThumbPointerDown: e => i.current = e\n      };\n    function f(e, r) {\n      return function (e, r, t) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"ltr\";\n        const n = R(t),\n          l = n / 2,\n          i = r || l,\n          a = n - i,\n          c = t.scrollbar.paddingStart + i,\n          s = t.scrollbar.size - t.scrollbar.paddingEnd - a,\n          u = t.content - t.viewport;\n        return L([c, s], \"ltr\" === o ? [0, u] : [-1 * u, 0])(e);\n      }(e, i.current, a, r);\n    }\n    return \"horizontal\" === t ? /*#__PURE__*/s.createElement(S, u({}, p, {\n      ref: r,\n      onThumbPositionChange: () => {\n        if (n.viewport && l.current) {\n          const e = P(n.viewport.scrollLeft, a, n.dir);\n          l.current.style.transform = `translate3d(${e}px, 0, 0)`;\n        }\n      },\n      onWheelScroll: e => {\n        n.viewport && (n.viewport.scrollLeft = e);\n      },\n      onDragScroll: e => {\n        n.viewport && (n.viewport.scrollLeft = f(e, n.dir));\n      }\n    })) : \"vertical\" === t ? /*#__PURE__*/s.createElement(g, u({}, p, {\n      ref: r,\n      onThumbPositionChange: () => {\n        if (n.viewport && l.current) {\n          const e = P(n.viewport.scrollTop, a);\n          l.current.style.transform = `translate3d(0, ${e}px, 0)`;\n        }\n      },\n      onWheelScroll: e => {\n        n.viewport && (n.viewport.scrollTop = e);\n      },\n      onDragScroll: e => {\n        n.viewport && (n.viewport.scrollTop = f(e));\n      }\n    })) : null;\n  }),\n  S = /*#__PURE__*/s.forwardRef((e, r) => {\n    const {\n        sizes: t,\n        onSizesChange: o,\n        ...n\n      } = e,\n      i = h(\"ScrollAreaScrollbar\", e.__scopeScrollArea),\n      [a, c] = s.useState(),\n      d = s.useRef(null),\n      p = l(r, d, i.onScrollbarXChange);\n    return s.useEffect(() => {\n      d.current && c(getComputedStyle(d.current));\n    }, [d]), /*#__PURE__*/s.createElement(T, u({\n      \"data-orientation\": \"horizontal\"\n    }, n, {\n      ref: p,\n      sizes: t,\n      style: {\n        bottom: 0,\n        left: \"rtl\" === i.dir ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        right: \"ltr\" === i.dir ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        \"--radix-scroll-area-thumb-width\": R(t) + \"px\",\n        ...e.style\n      },\n      onThumbPointerDown: r => e.onThumbPointerDown(r.x),\n      onDragScroll: r => e.onDragScroll(r.x),\n      onWheelScroll: (r, t) => {\n        if (i.viewport) {\n          const o = i.viewport.scrollLeft + r.deltaX;\n          e.onWheelScroll(o), _(o, t) && r.preventDefault();\n        }\n      },\n      onResize: () => {\n        d.current && i.viewport && a && o({\n          content: i.viewport.scrollWidth,\n          viewport: i.viewport.offsetWidth,\n          scrollbar: {\n            size: d.current.clientWidth,\n            paddingStart: A(a.paddingLeft),\n            paddingEnd: A(a.paddingRight)\n          }\n        });\n      }\n    }));\n  }),\n  g = /*#__PURE__*/s.forwardRef((e, r) => {\n    const {\n        sizes: t,\n        onSizesChange: o,\n        ...n\n      } = e,\n      i = h(\"ScrollAreaScrollbar\", e.__scopeScrollArea),\n      [a, c] = s.useState(),\n      d = s.useRef(null),\n      p = l(r, d, i.onScrollbarYChange);\n    return s.useEffect(() => {\n      d.current && c(getComputedStyle(d.current));\n    }, [d]), /*#__PURE__*/s.createElement(T, u({\n      \"data-orientation\": \"vertical\"\n    }, n, {\n      ref: p,\n      sizes: t,\n      style: {\n        top: 0,\n        right: \"ltr\" === i.dir ? 0 : void 0,\n        left: \"rtl\" === i.dir ? 0 : void 0,\n        bottom: \"var(--radix-scroll-area-corner-height)\",\n        \"--radix-scroll-area-thumb-height\": R(t) + \"px\",\n        ...e.style\n      },\n      onThumbPointerDown: r => e.onThumbPointerDown(r.y),\n      onDragScroll: r => e.onDragScroll(r.y),\n      onWheelScroll: (r, t) => {\n        if (i.viewport) {\n          const o = i.viewport.scrollTop + r.deltaY;\n          e.onWheelScroll(o), _(o, t) && r.preventDefault();\n        }\n      },\n      onResize: () => {\n        d.current && i.viewport && a && o({\n          content: i.viewport.scrollHeight,\n          viewport: i.viewport.offsetHeight,\n          scrollbar: {\n            size: d.current.clientHeight,\n            paddingStart: A(a.paddingTop),\n            paddingEnd: A(a.paddingBottom)\n          }\n        });\n      }\n    }));\n  }),\n  [E, C] = d(\"ScrollAreaScrollbar\"),\n  T = /*#__PURE__*/s.forwardRef((r, t) => {\n    const {\n        __scopeScrollArea: o,\n        sizes: i,\n        hasThumb: a,\n        onThumbChange: d,\n        onThumbPointerUp: p,\n        onThumbPointerDown: f,\n        onThumbPositionChange: m,\n        onDragScroll: w,\n        onWheelScroll: b,\n        onResize: v,\n        ...S\n      } = r,\n      g = h(\"ScrollAreaScrollbar\", o),\n      [C, T] = s.useState(null),\n      y = l(t, e => T(e)),\n      A = s.useRef(null),\n      x = s.useRef(\"\"),\n      R = g.viewport,\n      P = i.content - i.viewport,\n      L = n(b),\n      _ = n(m),\n      D = z(v, 10);\n    function W(e) {\n      if (A.current) {\n        const r = e.clientX - A.current.left,\n          t = e.clientY - A.current.top;\n        w({\n          x: r,\n          y: t\n        });\n      }\n    }\n    return s.useEffect(() => {\n      const e = e => {\n        const r = e.target;\n        (null == C ? void 0 : C.contains(r)) && L(e, P);\n      };\n      return document.addEventListener(\"wheel\", e, {\n        passive: !1\n      }), () => document.removeEventListener(\"wheel\", e, {\n        passive: !1\n      });\n    }, [R, C, P, L]), s.useEffect(_, [i, _]), H(C, D), H(g.content, D), /*#__PURE__*/s.createElement(E, {\n      scope: o,\n      scrollbar: C,\n      hasThumb: a,\n      onThumbChange: n(d),\n      onThumbPointerUp: n(p),\n      onThumbPositionChange: _,\n      onThumbPointerDown: n(f)\n    }, /*#__PURE__*/s.createElement(c.div, u({}, S, {\n      ref: y,\n      style: {\n        position: \"absolute\",\n        ...S.style\n      },\n      onPointerDown: e(r.onPointerDown, e => {\n        if (0 === e.button) {\n          e.target.setPointerCapture(e.pointerId), A.current = C.getBoundingClientRect(), x.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = \"none\", W(e);\n        }\n      }),\n      onPointerMove: e(r.onPointerMove, W),\n      onPointerUp: e(r.onPointerUp, e => {\n        e.target.releasePointerCapture(e.pointerId), document.body.style.webkitUserSelect = x.current, A.current = null;\n      })\n    })));\n  });\nexport const ScrollAreaThumb = /*#__PURE__*/s.forwardRef((r, t) => {\n  const {\n      __scopeScrollArea: o,\n      style: n,\n      ...i\n    } = r,\n    a = h(\"ScrollbarThumb\", o),\n    d = C(\"ScrollbarThumb\", o),\n    {\n      onThumbPositionChange: p\n    } = d,\n    f = l(t, e => d.onThumbChange(e)),\n    m = s.useRef(),\n    w = z(() => {\n      m.current && (m.current(), m.current = void 0);\n    }, 100);\n  return s.useEffect(() => {\n    const e = a.viewport;\n    if (e) {\n      const r = () => {\n        if (w(), !m.current) {\n          const r = D(e, p);\n          m.current = r, p();\n        }\n      };\n      return p(), e.addEventListener(\"scroll\", r), () => e.removeEventListener(\"scroll\", r);\n    }\n  }, [a.viewport, w, p]), d.hasThumb ? /*#__PURE__*/s.createElement(c.div, u({}, i, {\n    ref: f,\n    style: {\n      width: \"var(--radix-scroll-area-thumb-width)\",\n      height: \"var(--radix-scroll-area-thumb-height)\",\n      ...n\n    },\n    onPointerDownCapture: e(r.onPointerDownCapture, e => {\n      const r = e.target.getBoundingClientRect(),\n        t = e.clientX - r.left,\n        o = e.clientY - r.top;\n      d.onThumbPointerDown({\n        x: t,\n        y: o\n      });\n    }),\n    onPointerUp: e(r.onPointerUp, d.onThumbPointerUp)\n  })) : null;\n}); /*#__PURE__*/\nexport const ScrollAreaCorner = /*#__PURE__*/s.forwardRef((e, r) => {\n  const t = h(\"ScrollAreaCorner\", e.__scopeScrollArea),\n    o = Boolean(t.scrollbarX && t.scrollbarY);\n  return \"scroll\" !== t.type && o ? /*#__PURE__*/s.createElement(y, u({}, e, {\n    ref: r\n  })) : null;\n}); /*#__PURE__*/\nconst y = /*#__PURE__*/s.forwardRef((e, r) => {\n  const {\n      __scopeScrollArea: t,\n      ...o\n    } = e,\n    n = h(\"ScrollAreaCorner\", t),\n    [l, i] = s.useState(0),\n    [a, d] = s.useState(0),\n    p = Boolean(l && a);\n  return H(n.scrollbarX, () => {\n    var e;\n    const r = (null === (e = n.scrollbarX) || void 0 === e ? void 0 : e.offsetHeight) || 0;\n    n.onCornerHeightChange(r), d(r);\n  }), H(n.scrollbarY, () => {\n    var e;\n    const r = (null === (e = n.scrollbarY) || void 0 === e ? void 0 : e.offsetWidth) || 0;\n    n.onCornerWidthChange(r), i(r);\n  }), p ? /*#__PURE__*/s.createElement(c.div, u({}, o, {\n    ref: r,\n    style: {\n      width: l,\n      height: a,\n      position: \"absolute\",\n      right: \"ltr\" === n.dir ? 0 : void 0,\n      left: \"rtl\" === n.dir ? 0 : void 0,\n      bottom: 0,\n      ...e.style\n    }\n  })) : null;\n});\nfunction A(e) {\n  return e ? parseInt(e, 10) : 0;\n}\nfunction x(e, r) {\n  const t = e / r;\n  return isNaN(t) ? 0 : t;\n}\nfunction R(e) {\n  const r = x(e.viewport, e.content),\n    t = e.scrollbar.paddingStart + e.scrollbar.paddingEnd,\n    o = (e.scrollbar.size - t) * r;\n  return Math.max(o, 18);\n}\nfunction P(e, t) {\n  let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ltr\";\n  const n = R(t),\n    l = t.scrollbar.paddingStart + t.scrollbar.paddingEnd,\n    i = t.scrollbar.size - l,\n    a = t.content - t.viewport,\n    c = i - n,\n    s = r(e, \"ltr\" === o ? [0, a] : [-1 * a, 0]);\n  return L([0, a], [0, c])(s);\n}\nfunction L(e, r) {\n  return t => {\n    if (e[0] === e[1] || r[0] === r[1]) return r[0];\n    const o = (r[1] - r[0]) / (e[1] - e[0]);\n    return r[0] + o * (t - e[0]);\n  };\n}\nfunction _(e, r) {\n  return e > 0 && e < r;\n}\nconst D = function (e) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  let t = {\n      left: e.scrollLeft,\n      top: e.scrollTop\n    },\n    o = 0;\n  return function n() {\n    const l = {\n        left: e.scrollLeft,\n        top: e.scrollTop\n      },\n      i = t.left !== l.left,\n      a = t.top !== l.top;\n    (i || a) && r(), t = l, o = window.requestAnimationFrame(n);\n  }(), () => window.cancelAnimationFrame(o);\n};\nfunction z(e, r) {\n  const t = n(e),\n    o = s.useRef(0);\n  return s.useEffect(() => () => window.clearTimeout(o.current), []), s.useCallback(() => {\n    window.clearTimeout(o.current), o.current = window.setTimeout(t, r);\n  }, [t, r]);\n}\nfunction H(e, r) {\n  const o = n(r);\n  t(() => {\n    let r = 0;\n    if (e) {\n      const t = new ResizeObserver(() => {\n        cancelAnimationFrame(r), r = window.requestAnimationFrame(o);\n      });\n      return t.observe(e), () => {\n        window.cancelAnimationFrame(r), t.unobserve(e);\n      };\n    }\n  }, [e, o]);\n}\nexport const Root = ScrollArea;\nexport const Viewport = ScrollAreaViewport;\nexport const Scrollbar = ScrollAreaScrollbar;\nexport const Thumb = ScrollAreaThumb;\nexport const Corner = ScrollAreaCorner;","map":{"version":3,"mappings":"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","names":["createScrollAreaContext","createScrollAreaScope","createContextScope","ScrollAreaProvider","useScrollAreaContext","ScrollArea","React","forwardRef","props","forwardedRef","__scopeScrollArea","type","scrollHideDelay","scrollAreaProps","scrollArea","setScrollArea","useState","viewport","setViewport","content","setContent","scrollbarX","setScrollbarX","scrollbarY","setScrollbarY","cornerWidth","setCornerWidth","cornerHeight","setCornerHeight","scrollbarXEnabled","setScrollbarXEnabled","scrollbarYEnabled","setScrollbarYEnabled","composedRefs","useComposedRefs","node","computedDirection","useDirection","dir","_react","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaProvider","scope","onViewportChange","onContentChange","onScrollbarXChange","onScrollbarXEnabledChange","onScrollbarYChange","onScrollbarYEnabledChange","onCornerWidthChange","onCornerHeightChange","Primitive","div","_babelRuntimeHelpersEsmExtends","ref","style","position","ScrollAreaViewport","children","viewportProps","context","useRef","dangerouslySetInnerHTML","__html","overflowX","overflowY","minWidth","display","ScrollAreaScrollbar","forceMount","scrollbarProps","isHorizontal","orientation","useEffect","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaScrollbarHover","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaScrollbarScroll","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaScrollbarAuto","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaScrollbarVisible","ScrollAreaScrollbarHover","visible","setVisible","hideTimer","handlePointerEnter","window","clearTimeout","handlePointerLeave","setTimeout","addEventListener","removeEventListener","Presence","present","ScrollAreaScrollbarScroll","debounceScrollEnd","useDebounceCallback","send","state","initialState","machine","hidden","SCROLL","scrolling","SCROLL_END","POINTER_ENTER","interacting","POINTER_LEAVE","idle","HIDE","useReducer","event","nextState","scrollDirection","prevScrollPos","handleScroll","scrollPos","onPointerEnter","composeEventHandlers","onPointerLeave","ScrollAreaScrollbarAuto","handleResize","isOverflowX","offsetWidth","scrollWidth","isOverflowY","offsetHeight","scrollHeight","useResizeObserver","ScrollAreaScrollbarVisible","thumbRef","pointerOffsetRef","sizes","setSizes","scrollbar","size","paddingStart","paddingEnd","thumbRatio","getThumbRatio","commonProps","onSizesChange","hasThumb","Boolean","onThumbChange","thumb","current","onThumbPointerUp","onThumbPointerDown","pointerPos","getScrollPosition","pointerOffset","thumbSizePx","getThumbSize","thumbCenter","offset","thumbOffsetFromEnd","minPointerPos","maxPointerPos","maxScrollPos","linearScale","interpolate","getScrollPositionFromPointer","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaScrollbarX","onThumbPositionChange","getThumbOffsetFromScroll","scrollLeft","transform","onWheelScroll","onDragScroll","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaScrollbarY","scrollTop","ScrollAreaScrollbarX","computedStyle","setComputedStyle","composeRefs","getComputedStyle","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaScrollbarImpl","bottom","left","right","x","deltaX","isScrollingWithinScrollbarBounds","preventDefault","onResize","clientWidth","toInt","paddingLeft","paddingRight","ScrollAreaScrollbarY","top","undefined","y","deltaY","clientHeight","paddingTop","paddingBottom","ScrollbarProvider","useScrollbarContext","ScrollAreaScrollbarImpl","setScrollbar","rectRef","prevWebkitUserSelectRef","handleWheelScroll","useCallbackRef","handleThumbPositionChange","handleDragScroll","clientX","clientY","handleWheel","element","target","contains","document","passive","$a2081f330f7bcc1f106df26ddcac79$var$ScrollbarProvider","onPointerDown","button","setPointerCapture","pointerId","getBoundingClientRect","body","webkitUserSelect","onPointerMove","onPointerUp","releasePointerCapture","ScrollAreaThumb","thumbProps","scrollAreaContext","scrollbarContext","composedRef","removeUnlinkedScrollListenerRef","listener","addUnlinkedScrollListener","width","height","onPointerDownCapture","thumbRect","ScrollAreaCorner","hasBothScrollbarsVisible","$a2081f330f7bcc1f106df26ddcac79$var$ScrollAreaCornerImpl","ScrollAreaCornerImpl","cornerProps","setWidth","setHeight","hasSize","value","parseInt","viewportSize","contentSize","ratio","isNaN","scrollbarPadding","thumbSize","Math","max","maxThumbPos","scrollWithoutMomentum","clamp","input","output","handler","prevPosition","rAF","loop","isHorizontalScroll","isVerticalScroll","requestAnimationFrame","cancelAnimationFrame","callback","delay","handleCallback","debounceTimerRef","useCallback","useLayoutEffect","resizeObserver","ResizeObserver","observe","unobserve","Root","Viewport","Scrollbar","Thumb","Corner"],"sources":["/Users/vincentlangat/Desktop/React-Projects/day19-social-media-app/node_modules/@radix-ui/react-scroll-area/dist/packages/react/scroll-area/src/ScrollArea.tsx","/Users/vincentlangat/Desktop/React-Projects/day19-social-media-app/node_modules/@radix-ui/react-scroll-area/dist/packages/react/scroll-area/src/useStateMachine.ts"],"sourcesContent":["/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { Presence } from '@radix-ui/react-presence';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useDirection } from '@radix-ui/react-use-direction';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useStateMachine } from './useStateMachine';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\ntype Sizes = {\n  content: number;\n  viewport: number;\n  scrollbar: {\n    size: number;\n    paddingStart: number;\n    paddingEnd: number;\n  };\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollArea\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLL_AREA_NAME = 'ScrollArea';\n\ntype ScopedProps<P> = P & { __scopeScrollArea?: Scope };\nconst [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);\n\ntype ScrollAreaContextValue = {\n  type: 'auto' | 'always' | 'scroll' | 'hover';\n  dir: Direction;\n  scrollHideDelay: number;\n  scrollArea: ScrollAreaElement | null;\n  viewport: ScrollAreaViewportElement | null;\n  onViewportChange(viewport: ScrollAreaViewportElement | null): void;\n  content: HTMLDivElement | null;\n  onContentChange(content: HTMLDivElement): void;\n  scrollbarX: ScrollAreaScrollbarElement | null;\n  onScrollbarXChange(scrollbar: ScrollAreaScrollbarElement | null): void;\n  scrollbarXEnabled: boolean;\n  onScrollbarXEnabledChange(rendered: boolean): void;\n  scrollbarY: ScrollAreaScrollbarElement | null;\n  onScrollbarYChange(scrollbar: ScrollAreaScrollbarElement | null): void;\n  scrollbarYEnabled: boolean;\n  onScrollbarYEnabledChange(rendered: boolean): void;\n  onCornerWidthChange(width: number): void;\n  onCornerHeightChange(height: number): void;\n};\n\nconst [ScrollAreaProvider, useScrollAreaContext] =\n  createScrollAreaContext<ScrollAreaContextValue>(SCROLL_AREA_NAME);\n\ntype ScrollAreaElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ScrollAreaProps extends PrimitiveDivProps {\n  type?: ScrollAreaContextValue['type'];\n  dir?: ScrollAreaContextValue['dir'];\n  scrollHideDelay?: number;\n}\n\nconst ScrollArea = React.forwardRef<ScrollAreaElement, ScrollAreaProps>(\n  (props: ScopedProps<ScrollAreaProps>, forwardedRef) => {\n    const { __scopeScrollArea, type = 'hover', scrollHideDelay = 600, ...scrollAreaProps } = props;\n    const [scrollArea, setScrollArea] = React.useState<ScrollAreaElement | null>(null);\n    const [viewport, setViewport] = React.useState<ScrollAreaViewportElement | null>(null);\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const [scrollbarX, setScrollbarX] = React.useState<ScrollAreaScrollbarElement | null>(null);\n    const [scrollbarY, setScrollbarY] = React.useState<ScrollAreaScrollbarElement | null>(null);\n    const [cornerWidth, setCornerWidth] = React.useState(0);\n    const [cornerHeight, setCornerHeight] = React.useState(0);\n    const [scrollbarXEnabled, setScrollbarXEnabled] = React.useState(false);\n    const [scrollbarYEnabled, setScrollbarYEnabled] = React.useState(false);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));\n    const computedDirection = useDirection(scrollArea, scrollAreaProps.dir);\n\n    return (\n      <ScrollAreaProvider\n        scope={__scopeScrollArea}\n        type={type}\n        dir={computedDirection}\n        scrollHideDelay={scrollHideDelay}\n        scrollArea={scrollArea}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        content={content}\n        onContentChange={setContent}\n        scrollbarX={scrollbarX}\n        onScrollbarXChange={setScrollbarX}\n        scrollbarXEnabled={scrollbarXEnabled}\n        onScrollbarXEnabledChange={setScrollbarXEnabled}\n        scrollbarY={scrollbarY}\n        onScrollbarYChange={setScrollbarY}\n        scrollbarYEnabled={scrollbarYEnabled}\n        onScrollbarYEnabledChange={setScrollbarYEnabled}\n        onCornerWidthChange={setCornerWidth}\n        onCornerHeightChange={setCornerHeight}\n      >\n        <Primitive.div\n          {...scrollAreaProps}\n          ref={composedRefs}\n          style={{\n            position: 'relative',\n            // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n            ['--radix-scroll-area-corner-width' as any]: cornerWidth + 'px',\n            ['--radix-scroll-area-corner-height' as any]: cornerHeight + 'px',\n            ...props.style,\n          }}\n        />\n      </ScrollAreaProvider>\n    );\n  }\n);\n\nScrollArea.displayName = SCROLL_AREA_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ScrollAreaViewport';\n\ntype ScrollAreaViewportElement = React.ElementRef<typeof Primitive.div>;\ninterface ScrollAreaViewportProps extends PrimitiveDivProps {}\n\nconst ScrollAreaViewport = React.forwardRef<ScrollAreaViewportElement, ScrollAreaViewportProps>(\n  (props: ScopedProps<ScrollAreaViewportProps>, forwardedRef) => {\n    const { __scopeScrollArea, children, ...viewportProps } = props;\n    const context = useScrollAreaContext(VIEWPORT_NAME, __scopeScrollArea);\n    const ref = React.useRef<ScrollAreaViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    return (\n      <>\n        {/* Hide scrollbars cross-browser and enable momentum scroll for touch devices */}\n        <style\n          dangerouslySetInnerHTML={{\n            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`,\n          }}\n        />\n        <Primitive.div\n          data-radix-scroll-area-viewport=\"\"\n          {...viewportProps}\n          ref={composedRefs}\n          style={{\n            /**\n             * We don't support `visible` because the intention is to have at least one scrollbar\n             * if this component is used and `visible` will behave like `auto` in that case\n             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n             *\n             * We don't handle `auto` because the intention is for the native implementation\n             * to be hidden if using this component. We just want to ensure the node is scrollable\n             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n             * the browser from having to work out whether to render native scrollbars or not,\n             * we tell it to with the intention of hiding them in CSS.\n             */\n            overflowX: context.scrollbarXEnabled ? 'scroll' : 'hidden',\n            overflowY: context.scrollbarYEnabled ? 'scroll' : 'hidden',\n            ...props.style,\n          }}\n        >\n          {/**\n           * `display: table` ensures our content div will match the size of its children in both\n           * horizontal and vertical axis so we can determine if scroll width/height changed and\n           * recalculate thumb sizes. This doesn't account for children with *percentage*\n           * widths that change. We'll wait to see what use-cases consumers come up with there\n           * before trying to resolve it.\n           */}\n          <div ref={context.onContentChange} style={{ minWidth: '100%', display: 'table' }}>\n            {children}\n          </div>\n        </Primitive.div>\n      </>\n    );\n  }\n);\n\nScrollAreaViewport.displayName = VIEWPORT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaScrollbar\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLLBAR_NAME = 'ScrollAreaScrollbar';\n\ntype ScrollAreaScrollbarElement = ScrollAreaScrollbarVisibleElement;\ninterface ScrollAreaScrollbarProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nconst ScrollAreaScrollbar = React.forwardRef<ScrollAreaScrollbarElement, ScrollAreaScrollbarProps>(\n  (props: ScopedProps<ScrollAreaScrollbarProps>, forwardedRef) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;\n    const isHorizontal = props.orientation === 'horizontal';\n\n    React.useEffect(() => {\n      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);\n      return () => {\n        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);\n      };\n    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);\n\n    return context.type === 'hover' ? (\n      <ScrollAreaScrollbarHover {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'scroll' ? (\n      <ScrollAreaScrollbarScroll {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'auto' ? (\n      <ScrollAreaScrollbarAuto {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'always' ? (\n      <ScrollAreaScrollbarVisible {...scrollbarProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nScrollAreaScrollbar.displayName = SCROLLBAR_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollAreaScrollbarHoverElement = ScrollAreaScrollbarAutoElement;\ninterface ScrollAreaScrollbarHoverProps extends ScrollAreaScrollbarAutoProps {\n  forceMount?: true;\n}\n\nconst ScrollAreaScrollbarHover = React.forwardRef<\n  ScrollAreaScrollbarHoverElement,\n  ScrollAreaScrollbarHoverProps\n>((props: ScopedProps<ScrollAreaScrollbarHoverProps>, forwardedRef) => {\n  const { forceMount, ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [visible, setVisible] = React.useState(false);\n\n  React.useEffect(() => {\n    const scrollArea = context.scrollArea;\n    let hideTimer = 0;\n    if (scrollArea) {\n      const handlePointerEnter = () => {\n        window.clearTimeout(hideTimer);\n        setVisible(true);\n      };\n      const handlePointerLeave = () => {\n        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);\n      };\n      scrollArea.addEventListener('pointerenter', handlePointerEnter);\n      scrollArea.addEventListener('pointerleave', handlePointerLeave);\n      return () => {\n        scrollArea.removeEventListener('pointerenter', handlePointerEnter);\n        scrollArea.removeEventListener('pointerleave', handlePointerLeave);\n      };\n    }\n  }, [context.scrollArea, context.scrollHideDelay]);\n\n  return (\n    <Presence present={forceMount || visible}>\n      <ScrollAreaScrollbarAuto\n        data-state={visible ? 'visible' : 'hidden'}\n        {...scrollbarProps}\n        ref={forwardedRef}\n      />\n    </Presence>\n  );\n});\n\ntype ScrollAreaScrollbarScrollElement = ScrollAreaScrollbarVisibleElement;\ninterface ScrollAreaScrollbarScrollProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nconst ScrollAreaScrollbarScroll = React.forwardRef<\n  ScrollAreaScrollbarScrollElement,\n  ScrollAreaScrollbarScrollProps\n>((props: ScopedProps<ScrollAreaScrollbarScrollProps>, forwardedRef) => {\n  const { forceMount, ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const isHorizontal = props.orientation === 'horizontal';\n  const debounceScrollEnd = useDebounceCallback(() => send('SCROLL_END'), 100);\n  const [state, send] = useStateMachine('hidden', {\n    hidden: {\n      SCROLL: 'scrolling',\n    },\n    scrolling: {\n      SCROLL_END: 'idle',\n      POINTER_ENTER: 'interacting',\n    },\n    interacting: {\n      SCROLL: 'interacting',\n      POINTER_LEAVE: 'idle',\n    },\n    idle: {\n      HIDE: 'hidden',\n      SCROLL: 'scrolling',\n      POINTER_ENTER: 'interacting',\n    },\n  });\n\n  React.useEffect(() => {\n    if (state === 'idle') {\n      const hideTimer = window.setTimeout(() => send('HIDE'), context.scrollHideDelay);\n      return () => window.clearTimeout(hideTimer);\n    }\n  }, [state, context.scrollHideDelay, send]);\n\n  React.useEffect(() => {\n    const viewport = context.viewport;\n    const scrollDirection = isHorizontal ? 'scrollLeft' : 'scrollTop';\n\n    if (viewport) {\n      let prevScrollPos = viewport[scrollDirection];\n      const handleScroll = () => {\n        const scrollPos = viewport[scrollDirection];\n        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n        if (hasScrollInDirectionChanged) {\n          send('SCROLL');\n          debounceScrollEnd();\n        }\n        prevScrollPos = scrollPos;\n      };\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);\n\n  return (\n    <Presence present={forceMount || state !== 'hidden'}>\n      <ScrollAreaScrollbarVisible\n        data-state={state === 'hidden' ? 'hidden' : 'visible'}\n        {...scrollbarProps}\n        ref={forwardedRef}\n        onPointerEnter={composeEventHandlers(props.onPointerEnter, () => send('POINTER_ENTER'))}\n        onPointerLeave={composeEventHandlers(props.onPointerLeave, () => send('POINTER_LEAVE'))}\n      />\n    </Presence>\n  );\n});\n\ntype ScrollAreaScrollbarAutoElement = ScrollAreaScrollbarVisibleElement;\ninterface ScrollAreaScrollbarAutoProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nconst ScrollAreaScrollbarAuto = React.forwardRef<\n  ScrollAreaScrollbarAutoElement,\n  ScrollAreaScrollbarAutoProps\n>((props: ScopedProps<ScrollAreaScrollbarAutoProps>, forwardedRef) => {\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const { forceMount, ...scrollbarProps } = props;\n  const [visible, setVisible] = React.useState(false);\n  const isHorizontal = props.orientation === 'horizontal';\n  const handleResize = useDebounceCallback(() => {\n    if (context.viewport) {\n      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;\n      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;\n      setVisible(isHorizontal ? isOverflowX : isOverflowY);\n    }\n  }, 10);\n\n  useResizeObserver(context.viewport, handleResize);\n  useResizeObserver(context.content, handleResize);\n\n  return (\n    <Presence present={forceMount || visible}>\n      <ScrollAreaScrollbarVisible\n        data-state={visible ? 'visible' : 'hidden'}\n        {...scrollbarProps}\n        ref={forwardedRef}\n      />\n    </Presence>\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollAreaScrollbarVisibleElement = ScrollAreaScrollbarAxisElement;\ninterface ScrollAreaScrollbarVisibleProps\n  extends Omit<ScrollAreaScrollbarAxisProps, keyof ScrollAreaScrollbarAxisPrivateProps> {\n  orientation?: 'horizontal' | 'vertical';\n}\n\nconst ScrollAreaScrollbarVisible = React.forwardRef<\n  ScrollAreaScrollbarVisibleElement,\n  ScrollAreaScrollbarVisibleProps\n>((props: ScopedProps<ScrollAreaScrollbarVisibleProps>, forwardedRef) => {\n  const { orientation = 'vertical', ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const thumbRef = React.useRef<ScrollAreaThumbElement | null>(null);\n  const pointerOffsetRef = React.useRef(0);\n  const [sizes, setSizes] = React.useState<Sizes>({\n    content: 0,\n    viewport: 0,\n    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 },\n  });\n  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);\n\n  type UncommonProps = 'onThumbPositionChange' | 'onDragScroll' | 'onWheelScroll';\n  const commonProps: Omit<ScrollAreaScrollbarAxisPrivateProps, UncommonProps> = {\n    ...scrollbarProps,\n    sizes,\n    onSizesChange: setSizes,\n    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),\n    onThumbChange: (thumb) => (thumbRef.current = thumb),\n    onThumbPointerUp: () => (pointerOffsetRef.current = 0),\n    onThumbPointerDown: (pointerPos) => (pointerOffsetRef.current = pointerPos),\n  };\n\n  function getScrollPosition(pointerPos: number, dir?: Direction) {\n    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);\n  }\n\n  if (orientation === 'horizontal') {\n    return (\n      <ScrollAreaScrollbarX\n        {...commonProps}\n        ref={forwardedRef}\n        onThumbPositionChange={() => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollLeft;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);\n            thumbRef.current.style.transform = `translate3d(${offset}px, 0, 0)`;\n          }\n        }}\n        onWheelScroll={(scrollPos) => {\n          if (context.viewport) context.viewport.scrollLeft = scrollPos;\n        }}\n        onDragScroll={(pointerPos) => {\n          if (context.viewport) {\n            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);\n          }\n        }}\n      />\n    );\n  }\n\n  if (orientation === 'vertical') {\n    return (\n      <ScrollAreaScrollbarY\n        {...commonProps}\n        ref={forwardedRef}\n        onThumbPositionChange={() => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollTop;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes);\n            thumbRef.current.style.transform = `translate3d(0, ${offset}px, 0)`;\n          }\n        }}\n        onWheelScroll={(scrollPos) => {\n          if (context.viewport) context.viewport.scrollTop = scrollPos;\n        }}\n        onDragScroll={(pointerPos) => {\n          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);\n        }}\n      />\n    );\n  }\n\n  return null;\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollAreaScrollbarAxisPrivateProps = {\n  hasThumb: boolean;\n  sizes: Sizes;\n  onSizesChange(sizes: Sizes): void;\n  onThumbChange(thumb: ScrollAreaThumbElement | null): void;\n  onThumbPointerDown(pointerPos: number): void;\n  onThumbPointerUp(): void;\n  onThumbPositionChange(): void;\n  onWheelScroll(scrollPos: number): void;\n  onDragScroll(pointerPos: number): void;\n};\n\ntype ScrollAreaScrollbarAxisElement = ScrollAreaScrollbarImplElement;\ninterface ScrollAreaScrollbarAxisProps\n  extends Omit<ScrollAreaScrollbarImplProps, keyof ScrollAreaScrollbarImplPrivateProps>,\n    ScrollAreaScrollbarAxisPrivateProps {}\n\nconst ScrollAreaScrollbarX = React.forwardRef<\n  ScrollAreaScrollbarAxisElement,\n  ScrollAreaScrollbarAxisProps\n>((props: ScopedProps<ScrollAreaScrollbarAxisProps>, forwardedRef) => {\n  const { sizes, onSizesChange, ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [computedStyle, setComputedStyle] = React.useState<CSSStyleDeclaration>();\n  const ref = React.useRef<ScrollAreaScrollbarAxisElement>(null);\n  const composeRefs = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);\n\n  React.useEffect(() => {\n    if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n  }, [ref]);\n\n  return (\n    <ScrollAreaScrollbarImpl\n      data-orientation=\"horizontal\"\n      {...scrollbarProps}\n      ref={composeRefs}\n      sizes={sizes}\n      style={{\n        bottom: 0,\n        left: context.dir === 'rtl' ? 'var(--radix-scroll-area-corner-width)' : 0,\n        right: context.dir === 'ltr' ? 'var(--radix-scroll-area-corner-width)' : 0,\n        ['--radix-scroll-area-thumb-width' as any]: getThumbSize(sizes) + 'px',\n        ...props.style,\n      }}\n      onThumbPointerDown={(pointerPos) => props.onThumbPointerDown(pointerPos.x)}\n      onDragScroll={(pointerPos) => props.onDragScroll(pointerPos.x)}\n      onWheelScroll={(event, maxScrollPos) => {\n        if (context.viewport) {\n          const scrollPos = context.viewport.scrollLeft + event.deltaX;\n          props.onWheelScroll(scrollPos);\n          // prevent window scroll when wheeling on scrollbar\n          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n            event.preventDefault();\n          }\n        }\n      }}\n      onResize={() => {\n        if (ref.current && context.viewport && computedStyle) {\n          onSizesChange({\n            content: context.viewport.scrollWidth,\n            viewport: context.viewport.offsetWidth,\n            scrollbar: {\n              size: ref.current.clientWidth,\n              paddingStart: toInt(computedStyle.paddingLeft),\n              paddingEnd: toInt(computedStyle.paddingRight),\n            },\n          });\n        }\n      }}\n    />\n  );\n});\n\nconst ScrollAreaScrollbarY = React.forwardRef<\n  ScrollAreaScrollbarAxisElement,\n  ScrollAreaScrollbarAxisProps\n>((props: ScopedProps<ScrollAreaScrollbarAxisProps>, forwardedRef) => {\n  const { sizes, onSizesChange, ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [computedStyle, setComputedStyle] = React.useState<CSSStyleDeclaration>();\n  const ref = React.useRef<ScrollAreaScrollbarAxisElement>(null);\n  const composeRefs = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);\n\n  React.useEffect(() => {\n    if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n  }, [ref]);\n\n  return (\n    <ScrollAreaScrollbarImpl\n      data-orientation=\"vertical\"\n      {...scrollbarProps}\n      ref={composeRefs}\n      sizes={sizes}\n      style={{\n        top: 0,\n        right: context.dir === 'ltr' ? 0 : undefined,\n        left: context.dir === 'rtl' ? 0 : undefined,\n        bottom: 'var(--radix-scroll-area-corner-height)',\n        ['--radix-scroll-area-thumb-height' as any]: getThumbSize(sizes) + 'px',\n        ...props.style,\n      }}\n      onThumbPointerDown={(pointerPos) => props.onThumbPointerDown(pointerPos.y)}\n      onDragScroll={(pointerPos) => props.onDragScroll(pointerPos.y)}\n      onWheelScroll={(event, maxScrollPos) => {\n        if (context.viewport) {\n          const scrollPos = context.viewport.scrollTop + event.deltaY;\n          props.onWheelScroll(scrollPos);\n          // prevent window scroll when wheeling on scrollbar\n          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n            event.preventDefault();\n          }\n        }\n      }}\n      onResize={() => {\n        if (ref.current && context.viewport && computedStyle) {\n          onSizesChange({\n            content: context.viewport.scrollHeight,\n            viewport: context.viewport.offsetHeight,\n            scrollbar: {\n              size: ref.current.clientHeight,\n              paddingStart: toInt(computedStyle.paddingTop),\n              paddingEnd: toInt(computedStyle.paddingBottom),\n            },\n          });\n        }\n      }}\n    />\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollbarContext = {\n  hasThumb: boolean;\n  scrollbar: ScrollAreaScrollbarElement | null;\n  onThumbChange(thumb: ScrollAreaThumbElement | null): void;\n  onThumbPointerUp(): void;\n  onThumbPointerDown(pointerPos: { x: number; y: number }): void;\n  onThumbPositionChange(): void;\n};\n\nconst [ScrollbarProvider, useScrollbarContext] =\n  createScrollAreaContext<ScrollbarContext>(SCROLLBAR_NAME);\n\ntype ScrollAreaScrollbarImplElement = React.ElementRef<typeof Primitive.div>;\ntype ScrollAreaScrollbarImplPrivateProps = {\n  sizes: Sizes;\n  hasThumb: boolean;\n  onThumbChange: ScrollbarContext['onThumbChange'];\n  onThumbPointerUp: ScrollbarContext['onThumbPointerUp'];\n  onThumbPointerDown: ScrollbarContext['onThumbPointerDown'];\n  onThumbPositionChange: ScrollbarContext['onThumbPositionChange'];\n  onWheelScroll(event: WheelEvent, maxScrollPos: number): void;\n  onDragScroll(pointerPos: { x: number; y: number }): void;\n  onResize(): void;\n};\ninterface ScrollAreaScrollbarImplProps\n  extends PrimitiveDivProps,\n    ScrollAreaScrollbarImplPrivateProps {}\n\nconst ScrollAreaScrollbarImpl = React.forwardRef<\n  ScrollAreaScrollbarImplElement,\n  ScrollAreaScrollbarImplProps\n>((props: ScopedProps<ScrollAreaScrollbarImplProps>, forwardedRef) => {\n  const {\n    __scopeScrollArea,\n    sizes,\n    hasThumb,\n    onThumbChange,\n    onThumbPointerUp,\n    onThumbPointerDown,\n    onThumbPositionChange,\n    onDragScroll,\n    onWheelScroll,\n    onResize,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);\n  const [scrollbar, setScrollbar] = React.useState<ScrollAreaScrollbarElement | null>(null);\n  const composeRefs = useComposedRefs(forwardedRef, (node) => setScrollbar(node));\n  const rectRef = React.useRef<ClientRect | null>(null);\n  const prevWebkitUserSelectRef = React.useRef<string>('');\n  const viewport = context.viewport;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const handleWheelScroll = useCallbackRef(onWheelScroll);\n  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);\n  const handleResize = useDebounceCallback(onResize, 10);\n\n  function handleDragScroll(event: React.PointerEvent<HTMLElement>) {\n    if (rectRef.current) {\n      const x = event.clientX - rectRef.current.left;\n      const y = event.clientY - rectRef.current.top;\n      onDragScroll({ x, y });\n    }\n  }\n\n  /**\n   * We bind wheel event imperatively so we can switch off passive\n   * mode for document wheel event to allow it to be prevented\n   */\n  React.useEffect(() => {\n    const handleWheel = (event: WheelEvent) => {\n      const element = event.target as HTMLElement;\n      const isScrollbarWheel = scrollbar?.contains(element);\n      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);\n    };\n    document.addEventListener('wheel', handleWheel, { passive: false });\n    return () => document.removeEventListener('wheel', handleWheel, { passive: false } as any);\n  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);\n\n  /**\n   * Update thumb position on sizes change\n   */\n  React.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);\n\n  useResizeObserver(scrollbar, handleResize);\n  useResizeObserver(context.content, handleResize);\n\n  return (\n    <ScrollbarProvider\n      scope={__scopeScrollArea}\n      scrollbar={scrollbar}\n      hasThumb={hasThumb}\n      onThumbChange={useCallbackRef(onThumbChange)}\n      onThumbPointerUp={useCallbackRef(onThumbPointerUp)}\n      onThumbPositionChange={handleThumbPositionChange}\n      onThumbPointerDown={useCallbackRef(onThumbPointerDown)}\n    >\n      <Primitive.div\n        {...scrollbarProps}\n        ref={composeRefs}\n        style={{ position: 'absolute', ...scrollbarProps.style }}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const mainPointer = 0;\n          if (event.button === mainPointer) {\n            const element = event.target as HTMLElement;\n            element.setPointerCapture(event.pointerId);\n            rectRef.current = scrollbar!.getBoundingClientRect();\n            // pointer capture doesn't prevent text selection in Safari\n            // so we remove text selection manually when scrolling\n            prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;\n            document.body.style.webkitUserSelect = 'none';\n            handleDragScroll(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, handleDragScroll)}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const element = event.target as HTMLElement;\n          element.releasePointerCapture(event.pointerId);\n          document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;\n          rectRef.current = null;\n        })}\n      />\n    </ScrollbarProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'ScrollbarThumb';\n\ntype ScrollAreaThumbElement = React.ElementRef<typeof Primitive.div>;\ninterface ScrollAreaThumbProps extends PrimitiveDivProps {}\n\nconst ScrollAreaThumb = React.forwardRef<ScrollAreaThumbElement, ScrollAreaThumbProps>(\n  (props: ScopedProps<ScrollAreaThumbProps>, forwardedRef) => {\n    const { __scopeScrollArea, style, ...thumbProps } = props;\n    const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);\n    const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);\n    const { onThumbPositionChange } = scrollbarContext;\n    const composedRef = useComposedRefs(forwardedRef, (node) =>\n      scrollbarContext.onThumbChange(node)\n    );\n    const removeUnlinkedScrollListenerRef = React.useRef<() => void>();\n    const debounceScrollEnd = useDebounceCallback(() => {\n      if (removeUnlinkedScrollListenerRef.current) {\n        removeUnlinkedScrollListenerRef.current();\n        removeUnlinkedScrollListenerRef.current = undefined;\n      }\n    }, 100);\n\n    React.useEffect(() => {\n      const viewport = scrollAreaContext.viewport;\n      if (viewport) {\n        /**\n         * We only bind to native scroll event so we know when scroll starts and ends.\n         * When scroll starts we start a requestAnimationFrame loop that checks for\n         * changes to scroll position. That rAF loop triggers our thumb position change\n         * when relevant to avoid scroll-linked effects. We cancel the loop when scroll ends.\n         * https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects\n         */\n        const handleScroll = () => {\n          debounceScrollEnd();\n          if (!removeUnlinkedScrollListenerRef.current) {\n            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);\n            removeUnlinkedScrollListenerRef.current = listener;\n            onThumbPositionChange();\n          }\n        };\n        onThumbPositionChange();\n        viewport.addEventListener('scroll', handleScroll);\n        return () => viewport.removeEventListener('scroll', handleScroll);\n      }\n    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);\n\n    return scrollbarContext.hasThumb ? (\n      <Primitive.div\n        {...thumbProps}\n        ref={composedRef}\n        style={{\n          width: 'var(--radix-scroll-area-thumb-width)',\n          height: 'var(--radix-scroll-area-thumb-height)',\n          ...style,\n        }}\n        onPointerDownCapture={composeEventHandlers(props.onPointerDownCapture, (event) => {\n          const thumb = event.target as HTMLElement;\n          const thumbRect = thumb.getBoundingClientRect();\n          const x = event.clientX - thumbRect.left;\n          const y = event.clientY - thumbRect.top;\n          scrollbarContext.onThumbPointerDown({ x, y });\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)}\n      />\n    ) : null;\n  }\n);\n\nScrollAreaThumb.displayName = THUMB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaCorner\n * -----------------------------------------------------------------------------------------------*/\n\nconst CORNER_NAME = 'ScrollAreaCorner';\n\ntype ScrollAreaCornerElement = ScrollAreaCornerImplElement;\ninterface ScrollAreaCornerProps extends ScrollAreaCornerImplProps {}\n\nconst ScrollAreaCorner = React.forwardRef<ScrollAreaCornerElement, ScrollAreaCornerProps>(\n  (props: ScopedProps<ScrollAreaCornerProps>, forwardedRef) => {\n    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);\n    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);\n    const hasCorner = context.type !== 'scroll' && hasBothScrollbarsVisible;\n    return hasCorner ? <ScrollAreaCornerImpl {...props} ref={forwardedRef} /> : null;\n  }\n);\n\nScrollAreaCorner.displayName = CORNER_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollAreaCornerImplElement = React.ElementRef<typeof Primitive.div>;\ninterface ScrollAreaCornerImplProps extends PrimitiveDivProps {}\n\nconst ScrollAreaCornerImpl = React.forwardRef<\n  ScrollAreaCornerImplElement,\n  ScrollAreaCornerImplProps\n>((props: ScopedProps<ScrollAreaCornerImplProps>, forwardedRef) => {\n  const { __scopeScrollArea, ...cornerProps } = props;\n  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);\n  const [width, setWidth] = React.useState(0);\n  const [height, setHeight] = React.useState(0);\n  const hasSize = Boolean(width && height);\n\n  useResizeObserver(context.scrollbarX, () => {\n    const height = context.scrollbarX?.offsetHeight || 0;\n    context.onCornerHeightChange(height);\n    setHeight(height);\n  });\n\n  useResizeObserver(context.scrollbarY, () => {\n    const width = context.scrollbarY?.offsetWidth || 0;\n    context.onCornerWidthChange(width);\n    setWidth(width);\n  });\n\n  return hasSize ? (\n    <Primitive.div\n      {...cornerProps}\n      ref={forwardedRef}\n      style={{\n        width,\n        height,\n        position: 'absolute',\n        right: context.dir === 'ltr' ? 0 : undefined,\n        left: context.dir === 'rtl' ? 0 : undefined,\n        bottom: 0,\n        ...props.style,\n      }}\n    />\n  ) : null;\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction toInt(value?: string) {\n  return value ? parseInt(value, 10) : 0;\n}\n\nfunction getThumbRatio(viewportSize: number, contentSize: number) {\n  const ratio = viewportSize / contentSize;\n  return isNaN(ratio) ? 0 : ratio;\n}\n\nfunction getThumbSize(sizes: Sizes) {\n  const ratio = getThumbRatio(sizes.viewport, sizes.content);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;\n  // minimum of 18 matches macOS minimum\n  return Math.max(thumbSize, 18);\n}\n\nfunction getScrollPositionFromPointer(\n  pointerPos: number,\n  pointerOffset: number,\n  sizes: Sizes,\n  dir: Direction = 'ltr'\n) {\n  const thumbSizePx = getThumbSize(sizes);\n  const thumbCenter = thumbSizePx / 2;\n  const offset = pointerOffset || thumbCenter;\n  const thumbOffsetFromEnd = thumbSizePx - offset;\n  const minPointerPos = sizes.scrollbar.paddingStart + offset;\n  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const scrollRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange as [number, number]);\n  return interpolate(pointerPos);\n}\n\nfunction getThumbOffsetFromScroll(scrollPos: number, sizes: Sizes, dir: Direction = 'ltr') {\n  const thumbSizePx = getThumbSize(sizes);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const scrollbar = sizes.scrollbar.size - scrollbarPadding;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const maxThumbPos = scrollbar - thumbSizePx;\n  const scrollClampRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange as [number, number]);\n  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);\n  return interpolate(scrollWithoutMomentum);\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction isScrollingWithinScrollbarBounds(scrollPos: number, maxScrollPos: number) {\n  return scrollPos > 0 && scrollPos < maxScrollPos;\n}\n\n// Custom scroll handler to avoid scroll-linked effects\n// https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects\nconst addUnlinkedScrollListener = (node: HTMLElement, handler = () => {}) => {\n  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };\n  let rAF = 0;\n  (function loop() {\n    const position = { left: node.scrollLeft, top: node.scrollTop };\n    const isHorizontalScroll = prevPosition.left !== position.left;\n    const isVerticalScroll = prevPosition.top !== position.top;\n    if (isHorizontalScroll || isVerticalScroll) handler();\n    prevPosition = position;\n    rAF = window.requestAnimationFrame(loop);\n  })();\n  return () => window.cancelAnimationFrame(rAF);\n};\n\nfunction useDebounceCallback(callback: () => void, delay: number) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = React.useRef(0);\n  React.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);\n  return React.useCallback(() => {\n    window.clearTimeout(debounceTimerRef.current);\n    debounceTimerRef.current = window.setTimeout(handleCallback, delay);\n  }, [handleCallback, delay]);\n}\n\nfunction useResizeObserver(element: HTMLElement | null, onResize: () => void) {\n  const handleResize = useCallbackRef(onResize);\n  useLayoutEffect(() => {\n    let rAF = 0;\n    if (element) {\n      /**\n       * Resize Observer will throw an often benign error that says `ResizeObserver loop\n       * completed with undelivered notifications`. This means that ResizeObserver was not\n       * able to deliver all observations within a single animation frame, so we use\n       * `requestAnimationFrame` to ensure we don't deliver unnecessary observations.\n       * Further reading: https://github.com/WICG/resize-observer/issues/38\n       */\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n  }, [element, handleResize]);\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = ScrollArea;\nconst Viewport = ScrollAreaViewport;\nconst Scrollbar = ScrollAreaScrollbar;\nconst Thumb = ScrollAreaThumb;\nconst Corner = ScrollAreaCorner;\n\nexport {\n  createScrollAreaScope,\n  //\n  ScrollArea,\n  ScrollAreaViewport,\n  ScrollAreaScrollbar,\n  ScrollAreaThumb,\n  ScrollAreaCorner,\n  //\n  Root,\n  Viewport,\n  Scrollbar,\n  Thumb,\n  Corner,\n};\nexport type {\n  ScrollAreaProps,\n  ScrollAreaViewportProps,\n  ScrollAreaScrollbarProps,\n  ScrollAreaThumbProps,\n  ScrollAreaCornerProps,\n};\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}